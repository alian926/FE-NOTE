# HTTP

## 1. HTTP是什么？

HTTP是超文本传输协议，也就是HyperText Transfer Protocol。可以分成3个方面来理解，协议、传输、超文本。

 	1. 协议： HTTP是一个用在计算机世界里的协议。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范（两个以上的参与者），以及相关的各种控制和错误处理方式（行为约定和规范）。
 	2. 传输： HTTP是一个双向协议。HTTP是一个专门在计算机世界用来在两点之间传输数据的约定和规范，它允许中间有中转或接力，中间人需要遵从HTTP协议，只要不打扰基本的数据传输，就可以添加任意额外的信息。
 	3. 超文本： 在HTTP眼中，文本的含义为文字、图片、视频、压缩包等，超文本即在文本的基础上拥有最关键的超链接，能从一个超文本跳转到另一个超文本。

*HTTP是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范。



## 2.HTTP是用于从互联网服务器传输超文本到本地浏览器的协议，这种说法正确么？

这种说法不正确。因为也可以是从服务器<--->服务器之间进行数据传输，所以采用两点之间描述会更加准确。



## 3.HTTP常见的状态码有哪些？

有5大类HTTP状态码：

1. 1xx 提示信息，表示目前是协议处理的中间状态，会需要后续的操作。
2. 2xx, 成功，报文已经收到并被正确处理。
3. 3xx, 重定向，资源位置发生变动，需要客户端重新发送请求。
4. 4xx, 客户端错误，请求报文有误，服务器无法处理。
5. 5xx, 服务器错误，服务器在处理请求时内部发生了错误。

200 OK， 最常见的成功状态码，表示一切正常，非HEAD请求，服务器返回的响应都会有body数据。

204 No Content, 与200基本相同，但响应没有body数据。

206 Partial Content, 是用于HTTP分块下载或断点续传，表示响应返回的body数据并不是资源的全部，而是其中的一部分。

301 Moved Permanently, 表示永久重定向，说明请求的资源不存在，需要用新的URL再次访问。

302 Found, 表示临时重定向，说明请求的资源还在，但暂时需要另一个URL访问。

301和302都会再响应头里使用字段Location, 指明后续要跳转的URL，浏览器会自动重定向新的URL。

304 Not Modified, 不具有跳转的含义， 表示资源未修改，重定向已存在的缓冲文件，也称缓冲重定向，用于缓存控制。

303， HTTP 1.1中加入的状态码，用于在不需要询问用户的时候，直接进行重定向，可以将发起的POST转为GET请求。

307， HTTP 1.1中加入的状态码， 需要跟用户询问是否应该在新URI上发起POST请求，不会将POST转为GET。

400 Bad Request, 表示客户端请求的报文有错误，是一个笼统的错误。

401 Unauthorized, 表示请求要求身份验证。

403 Forbidden， 表示服务器禁止访问资源，并不是客户端的请求出错，通常是指用户无权限。

404 Not Found, 表示请求的资源在服务器上不存在或未找到， 无法提供给客户端。

500 Internal Server Error, 服务器发生了错误，是一个笼统的错误。

501 Not Implemented， 表示客户端请求的功能还不支持， 类似“还在维护，等待一段时间后开放，敬请期待”

502 Bad Gateway, 通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生错误。

503 Service Unavailable, 表示服务器当前很忙，暂时无法响应服务器，类似“网络服务正忙，请稍后重试”

## 4.HTTP常见字段有哪些？

Host, 客户端发送请求时， 用来指定服务器的域名。

Content-Length，服务器返回数据时，表示本次返回的数据长度。

Connection: Keep-Alive, 客户端要求服务器使用TCP持久连接，以便于其它请求复用。为了兼容老版本的HTTP使用，但是这不是标准字段。

Content-Type, 用于服务器回应时，告诉客户端，本次数据是什么格式。

Content-Encoding， 表示服务器返回的数据使用了什么压缩格式。

Accept-Encoding， 表示客户端在请求时，可以接受的压缩方法。

Cache-Control：控制强缓存的行为。

ETag：服务器返回的资源的匹配信息。

If-None-Match： (Etag)， 协商缓存。

If-Modified-Since： 比较资源的更新时间。

Last-Modified：资源的最后修改日期时间。

## 5.GET和POST的区别？

GET方法的含义是请求从服务器获取资源，这个资源可以是静态的文本、页面、图片、视频等。

POST是相反的操作，向URI指定的资源提交数据，数据就放在报文的body里面。

## 6.GET和POST都是安全和幂等的么？

在HTTP协议中，安全是指请求方法不会破坏服务器上的资源。

幂等，意思在多次执行相同的操作，结果都是相同的。

GET方法是幂等且安全的，它是只读操作，无论执行多少次，服务器上的数据都不会受到影响，且每次的结果都是相同的。

POST会修改服务器上的资源，所以是不安全的，且多次提交会创建多个资源，所以不是幂等的。

## 7.HTTP1.1的有点有哪些，怎么体现的？

HTTP最突出的优点就是 简单、灵活、易于扩展、应用广泛和跨平台。

简单，HTTP基本的报文格式就是header+body，头部信息也是key-value简单文本的形式，易于理解。

灵活和易于扩展，HTTP协议里的各类请求方法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员自定义核扩充。

HTTP是应用层协议， 下层可以随意变化。HTTPS就是在HTTP与TCP层之间增加了SSL/TLS安全传输层，HTTP/3甚至把TCP层换成了基于UDP的QUIC。

基于HTTP的应用遍地开花，天然具有跨平台的优越性。

## 8.HTTP的缺点有哪些？

HTTP协议里的优缺点一题的双刃剑，分别是无状态、明文传输，同时还有一大缺点不安全。

无状态的好处，因为服务器不会记忆HTTP的状态，所以不需要额外的资源来记录状态信息，能减轻服务器的负担，能够把更多的CPU和内存用来对外提供服务。

无状态的坏处，由于服务器没有记忆能力，在完成有关联性的操作时会非常麻烦。每一次关联操作，都需要验证信息。通过Cookie技术，可以在请求和响应报文中写入Cookie信息来控制客户端的状态。

明文意味着在传输过程中的信息，是可以方便阅读的，通过控制台或抓包都可以直接肉眼查看，为调试工作带来极大的便利。正是这样，HTTP在漫长的传输过程中，很容器就被窃取盗用。

HTTP的一大缺点就是不安全：

* 通信使用明文，内容很可能会被窃听， 比如账号信息泄漏。
* 不验证通信的身份，因此很可能遭遇伪装，比如登录假的网站。
* 无法验证报文的完整性，内容可能被篡改，比如页面被植入垃圾广告。

因此，可以使用HTTPS来解决HTTP的安全问题。

## 9.HTTP1.1的性能如何？

HTTP协议是基于TCP/IP，并且使用了请求-应答的通信模式，所以性能的关键就在这两点。

* 长链接：

  早起HTTP1.0每发起一个请求，都要新建立一次TCP连接，而且是串行请求，做了无谓的TCP连接建立和断开，增加了通信开销。解决上述TCP连接问题，HTTP1.1提出了长链接的通信方式，也叫持久连接。这种方式的好处在于减少了TCP连接的重复建立和断开所造成的额外开销，减轻服务器负担。

  持久连接的特点是，只要任意一段没有明确的提出断开连接，则保持TCP连接状态。

* 管道网络传输：

  HTTP1.1采用了长连接的方式，这使得管道网络传输成为了可能。即可以在同一个TCP连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出来，减少整体的响应时间。

  服务器还是按照顺序，依次回应请求，如果前面的回应特别慢，后面后又许多请求排队等着，这称为队头堵塞。

总之HTTP1.1的性能一般，后续的HTTP2,HTTP3就是在优化HTTP的性能。

## 10.HTTP和HTTPS有哪些区别？

1. HTTP是超文本传输协议，信息是明文传输，穿在安全风险的问题。HTTPS解决HTTP不安全的缺陷，在TCP和HTTP网络层之间加入了SSL/TLS安全协议，使得报文能够加密传输。
2. HTTP连接建立简单，TCP三次握手之后便可以进行HTTP的报文传输。而HTTPS在TCP三次握手之后，还需要进行SSL/TLS的握手过程，才可以进入加密报文传输。
3. HTTP的默认端口号是80，HTTPS的默认端口号是443。
4. HTTPS协议需要向CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。

## 11.HTTPS解决了HTTP的哪些问题？

HTTP由于是明文传输，所以可能存在三个风险：窃听风险、篡改风险，冒充风险。

HTTPS在HTTP于TCP层之间加入了SSL/TLS协议，可以很好的解决了上述的风险：

* 信息加密：交互信息无法被窃取。
* 检验机制：无法篡改通信内容，篡改了就不能正常显示。
* 身份证书：证明网站真实可信。

## 12.HTTPS如何解决上面的风险的？

* 混合加密的方式实现信息的机密性，解决了窃听风险。
* 摘要算法实现完整性，能够为数据生成独一无二的指纹，用于检验数据的完整性，解决了篡改风险。
* 将服务器公钥放入数字证书中，解决了冒充风险。

HTTPS采用对称加密和非对称加密结合的混合加密方式：在通信建立前采用非对称加密的方式交换会话秘钥，后续就不再使用非对称加密。在通信过程中全部使用对称加密的会话秘钥的方式加密明文数据。

重用混合加密的方式的原因：对称加密只使用一个秘钥，运算速度快，秘钥必须保密，无法做到安全的秘钥交换。

非对称加密使用两个秘钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了秘钥交换问题但速度慢。



客户端在发送明文之前会通过摘要算法算出明文的「指纹」，发送的时候把「指纹 + 明文」一同 加密成密文后，发送给服务器，服务器解密后，用相同的摘要算法算出发送过来的明文，通过比较客户端携带的「指纹」和当前算出的「指纹」做比较，若「指纹」相同，说明数据是完整的。

客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。这就存在些问题，如何保证公钥不被篡改和信任度？所以这里就需要借助第三方权威机构 `CA` （数字证书认证机构），将**服务器公钥放在数字证书**（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。

## 13.HTTPS是如何建立连接的？其间交互了什么？

SSL/TLS协议基本流程：

* 客户端向服务器索要并验证服务器的公钥。
* 双方协商生产会话秘钥。
* 双方采用会话秘钥进行加密通信。

前两步就是SSL/TLS的建立阶段也就是握手阶段，其中涉及**四次**通信。

SSL/TLS协议建立的详细流程：

1. ClientHello

   首先，由客户端向服务器发起加密通信请求，也就是ClientHello请求。

   在这一步，客户端主要向服务器发送以下信息:

   ​	a.	客户端支持的SSL/TLS协议版本，如TLS1.2版本。

   ​	b.	客户端生产的随机数（Client Random)，后面用于生产会话秘钥。

   ​	c. 	客户端支持的密码套件列表， 如RSA加密算法。

2. ServerHello

   服务器收到客户端请求后，向客户端发出响应，也就是ServerHello,有如下内容：

   ​	a.	确认SSL/TLS协议版本，如果浏览器不支持，则关闭加密通信。

   ​	b.	服务器生产的随机数（Server Random)，后面用于生产会话秘钥。

   ​	c.	确认的密码套件列表，如RSA加密算法。

   ​	d.	服务器的数字证书。

3. 客户端回应

   客户端收到服务器的回应之后，首先通过浏览器或操作系统中的CA公钥，确认服务器的数字证书的真实性。

   如果证书没有问题，客户端会从数字证书取出服务器的公钥，然后使用它加密报文，向服务器发送如下信息：

   ​	a.	一个随机数（pre-master key)， 该随机数会被服务器公钥加密。

   ​	b.	加密通信算法改变通知， 表示随后的信息都将用会话秘钥加密通信。

   ​	c.	客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个			摘要，用来供服务端校验。

   第三个随机数是加密的，这样服务器和客户端就同时有三个随机数，用双方协商的加密算法，各自生成本次通信的会话秘钥。

4. 服务器最后的回应

   服务器收到客户端的第三个随机数（pre-master key)之后，通过协商的加密算法，计算出本次通信的会话秘钥，然后，向客户端发出最后的信息：

   ​	a.	加密通信算法改变通知，表示随后的信息都将采用会话秘钥加密通信。

   ​	b.	服务器握手结束通知，表示服务器的握手阶段已经结束。同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。

至此，整个SSL/TLS握手阶段全部结束。接下来，客户端和服务器进入加密通信，就完全使用普通的HTTP协议，只不过用会话秘钥加密内容。

## 14. HTTP1.1相比HTTP1.0提高了什么性能？

HTTP1.1相比HTTP1.0性能上的改进：

* 使用TCP长连接的方式改善了HTTP1.0短连接造成的性能开销。
* 支持管道网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，减少整体的响应时间。

但HTTP1.1还是有性能瓶颈：

* 请求/响应头部未经压缩就发送，收不信息越多延迟越大。只压缩了body的部分。
* 发送冗长的首部，每次互相发送相同的首部造成的浪费比较多。
* 服务器是按请求的顺序响应的，如果服务器响应慢，会导致客户端一直请求不到数据，也就是队头堵塞。
* 没有请求优先级控制。
* 请求只能从客户端开始，服务器只能被动响应。

## 15. HTTP2做出了什么优化？

HTTP2是基于HTTPS的，所以HTTP2的安全性也是有保障的。

相比HTTP1.1性能上的改进：

* 头部压缩。HTTP2会压缩头部，如果同时发出多个请求，他们的头是一样的或者是相似的，那么，协议会帮你消除重复的部分。这就是所谓的HPACK算法：在客户端和服务器同时维护一张头信息表，所有字段都会传入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，提高速度。
* 二进制格式。 HTTP2不再像HTTP1.1里的纯文本形式的报文，而是全面采用了二进制格式，头信息和数据体都是二进制，并且统称为帧（frame)：头信息帧和数据帧。虽然对人不友好，但是对只懂二进制的计算机非常友好，在计算机收到报文后，无需再将明文的报文转换成二进制，而是直接解析二进制报文，增加数据传输的效率。
* 数据流。HTTP2的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的响应。因此，必须要对数据包做标记，指出它数据哪个回应。每个请求或回应的所有数据包，成为一个数据流。每个数据流都标记着一个独一无二的标号，其中规定客户端发出的数据流编号为奇数，服务器发出的数据流编号为偶总是。客户端可以指定数据流的优先级，优先级越高的请求，服务器就先响应该请求。
* 多路复用。HTTP2是可以在一个连接中并发多个请求或回应，而不用按照顺序一一对应。移除了HTTP1.1中的串行请求，不需要排队等待，不会出现队头堵塞。降低了延迟，大幅度提高了连接的利用率。
* 服务器推送。服务器可以主动地向客户端发送笑死。例如，在浏览器刚请求HTML的时候，就提前把可能会用到的JS、CSS等静态资源主动发给客户端，减少延时的等待，也就是服务器推送。

## 16. HTTP2有哪些缺陷，HTTP做出了什么优化？

HTTP2主要的问题在于，多个HTTP请求在复用一个TCP连接，下层的TCP协议是不知道有多少个HTTP请求的。所以一旦发生了丢包现象，就会触发TCP的重传机制，这样再一个TCP连接里的所有HTTP请求都必须等待这个丢了的包被重传回来。

HTTP3基于此问题，将下层的TCP协议改成了UDP。

UDP是不可靠传输，但基于UDP的QUIC协议可以实现类似TCP的可靠性传输。

* QUIC有自己的一套机制可以保证传输的可靠性。当某个流发生丢包时，只会阻塞这个流，其它流不会受到影响。
* 头部压缩算法升级成QPack。
* HTTPS要建立一个连接，要花费6次交互，先是建立三次握手，然后是TLS1.3的三次握手。QUIC直接把以往的TCP和TLS1.3的6次交互合并成了3次。减少交互次数。

所以，QUIC是一个在UDP之上的伪TCP+TLS+HTTP2的多路复用的协议。















